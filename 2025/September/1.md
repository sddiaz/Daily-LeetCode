# Maximum Average Pass Ratio

**LeetCode Problem**: [Maximum Average Pass Ratio](https://leetcode.com/problems/maximum-average-pass-ratio/)

## Problem Overview

Given classes with pass/total student counts and extra brilliant students (guaranteed to pass), assign the extra students to maximize the average pass ratio across all classes.

## Key Insights

### Initial Intuition vs Reality

- **First thought**: Always assign to the class with the lowest current ratio
- **Reality**: This doesn't work! We need to consider **marginal improvement**, not current ratio

### Example Analysis

```
classes = [[1,2],[3,5],[2,2]], extraStudents = 2
Current ratios: 0.5, 0.6, 1.0

❌ Wrong approach: Always pick lowest ratio
1. Add to class 0: [[2,3],[3,5],[2,2]] → ratios: 0.67, 0.6, 1.0
2. Add to class 1: [[2,3],[4,6],[2,2]] → suboptimal result

✅ Correct approach: Pick maximum marginal improvement
1. Add to class 0: improvement = 2/3 - 1/2 = 0.167
2. Add to class 0 again: improvement = 3/4 - 2/3 = 0.083
```

## Solution Strategy

**Greedy Algorithm with Max Heap**

- Always assign to the class that would gain the most improvement
- Use a max heap to efficiently find the best choice each time

### Marginal Improvement Formula

```
improvement = (pass + 1)/(total + 1) - pass/total
```

## Algorithm Steps

1. Calculate initial marginal improvement for all classes
2. Add all classes to a max heap (ordered by improvement)
3. For each extra student:
   - Extract class with maximum improvement
   - Add student to that class
   - Recalculate improvement and re-insert
4. Calculate final average pass ratio

## Complexity Analysis

- **Time**: O(n + extraStudents × log n)
- **Space**: O(n) for the heap

## Implementation Notes

- **Python**: Use `heapq` with negated values (min heap → max heap)
- **TypeScript**: Custom MaxHeap implementation required
- **Java**: `PriorityQueue` with custom comparator

## Learning Takeaways

- **Time taken**: 45 minutes
- **Hints needed**: 2
  1. Use heap data structure
  2. Focus on marginal improvement, not current ratio
- **Key lesson**: In optimization problems, consider the _change_ each action produces, not just the current state

## Similar Problems

This problem teaches the important concept of **greedy algorithms with priority queues** - useful for many optimization problems where you repeatedly make the locally optimal choice.
