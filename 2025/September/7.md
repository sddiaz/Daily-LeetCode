# Find N Unique Integers Sum up to Zero

**LeetCode Problem**: [1304. Find N Unique Integers Sum up to Zero](https://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero/)

---

## Problem Overview

Given an integer `n`, return any array of `n` unique integers such that their sum is 0.
Multiple valid answers exist.

---

## Key Insights

### First Thought

* Could try randomly picking numbers until they add to 0.
* ❌ Bad idea — inefficient and hard to ensure uniqueness.

### Correct Approach

* Notice symmetry:
  For every positive number `k`, add `-k`.
  Their sum cancels out.
* If `n` is odd, just add `0` in the middle.

---

## Example Analysis

```
n = 5
Output: [-2, -1, 0, 1, 2]   (sum = 0)

n = 4
Output: [-2, -1, 1, 2]      (sum = 0)

n = 1
Output: [0]
```

We don’t need the *same* answer every time — just a valid set of unique integers summing to 0.

---

## Solution Strategy

**Symmetry construction**:

* Generate numbers from `-⌊n/2⌋` to `⌊n/2⌋`
* Skip `0` if `n` is even
* That guarantees `n` numbers that add up to 0

---

## Algorithm Steps

1. If `n == 1`, return `[0]`
2. Let `bound = ⌊n/2⌋`
3. Add numbers `-bound` to `-1`
4. If `n` is odd, add `0`
5. Add numbers `1` to `bound`

---

## Complexity

* **Time**: O(n) (loop to build result)
* **Space**: O(n)

---

## Implementations

### Python

```python
class Solution:
    def sumZero(self, n: int) -> List[int]:
        result = []
        bound = n // 2

        for i in range(1, bound + 1):
            result.append(-i)
            result.append(i)

        if n % 2 == 1:
            result.append(0)

        return result
```

---

### JavaScript

```javascript
var sumZero = function(n) {
    if (n === 1) return [0];
    
    let result = [];
    let bound = Math.floor(n / 2);

    for (let i = 1; i <= bound; i++) {
        result.push(-i, i);
    }

    if (n % 2 !== 0) {
        result.push(0);
    }

    return result;
};
```

---

### Java

```java
class Solution {
    public int[] sumZero(int n) {
        int[] result = new int[n];
        int index = 0;

        for (int i = 1; i <= n / 2; i++) {
            result[index++] = -i;
            result[index++] = i;
        }

        if (n % 2 == 1) {
            result[index] = 0;
        }

        return result;
    }
}
```

---

## Learning Takeaways

* Don’t overcomplicate — look for **mathematical structure**.
* Symmetry (pairs `-x` and `+x`) solves the problem cleanly.
* This is a **constructive algorithm** problem, not optimization.
