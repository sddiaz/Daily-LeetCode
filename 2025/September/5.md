# Minimum Operations to Make the Integer Zero

**LeetCode Problem**: [2749. Minimum Operations to Make the Integer Zero](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/)

---

## Problem Overview

We’re given two integers `num1` and `num2`.

In **one operation**, we can choose any integer `i` in `[0, 60]` and subtract `(2^i + num2)` from `num1`.

Return the **minimum number of operations** to make `num1 = 0`, or `-1` if impossible.

---

## Key Insights

### 1. Reformulating the Problem

After `k` operations:

```
num1 - k * num2 - (2^i1 + 2^i2 + ... + 2^ik) = 0
```

So:

```
num1 - k * num2 = sum of k powers of 2
```

That means:

* The leftover `d = num1 - k * num2` must be representable as the sum of exactly `k` powers of two.

---

### 2. Binary Representation Constraint

* The **minimum number of powers of two** needed to represent `d` = **number of 1s in binary representation of d**.
* For example:

  * `d = 13 (1101b)` → needs at least 3 powers of two (8 + 4 + 1).

Thus the condition:

```
countOnes(d) ≤ k ≤ d
```

---

### 3. Why `d ≥ k`?

Because the smallest `k` numbers from powers of two sum to at least `k`.
Example: if we want `k=5` numbers, smallest possible sum is `1+1+1+1+1=5`.
So `d` must be ≥ `k`.

---

## Algorithm

1. Loop over possible number of operations `k` (from `1` to `60`).
2. Compute `d = num1 - num2*k`.
3. If `d < k`, break (impossible beyond this point).
4. If `countOnes(d) ≤ k ≤ d`, return `k`.
5. If no `k` works, return `-1`.

---

## Complexity

* **Time**: O(60) ≈ O(1)
* **Space**: O(1)

---

## Implementations

### Python

```python
class Solution:
    def makeTheIntegerZero(self, num1: int, num2: int) -> int:
        def count_ones(n: int) -> int:
            return bin(n).count("1")

        for k in range(1, 61):
            d = num1 - num2 * k
            if d < k:
                return -1
            if count_ones(d) <= k <= d:
                return k
        return -1
```

---

### JavaScript

```javascript
var makeTheIntegerZero = function(num1, num2) {
    const countOnes = n => n.toString(2).replace(/0/g, '').length;

    for (let k = 1; k <= 60; k++) {
        let d = num1 - num2 * k;
        if (d < k) {
            return -1;
        }
        if (countOnes(d) <= k && k <= d) {
            return k;
        }
    }
    return -1;
};
```

---

### Java

```java
class Solution {
    public int makeTheIntegerZero(int num1, int num2) {
        for (int k = 1; k <= 60; k++) {
            long d = (long) num1 - (long) num2 * k;
            if (d < k) return -1;
            if (Long.bitCount(d) <= k && k <= d) {
                return k;
            }
        }
        return -1;
    }
}
```

---

## Learning Takeaways

* This is really a **number theory + bit manipulation** problem.
* Key trick: translate the operation into **representing a number as the sum of powers of two**.
* Constraint `countOnes(d) ≤ k ≤ d` is the crucial insight.