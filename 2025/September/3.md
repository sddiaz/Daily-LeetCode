# Find the Number of Ways to Place People II

**LeetCode Problem**: [Find the Number of Ways to Place People II](https://leetcode.com/problems/find-the-number-of-ways-to-place-people-ii/)

## Problem Overview

Given a 2D array of integer coordinates, count the number of pairs of points (Alice, Bob) where Alice can be placed at the upper-left corner and Bob at the lower-right corner of a rectangular fence, with no other people inside or on the fence boundary.

## Key Insights

### Understanding "Upper-Left to Lower-Right"

Alice can be at the upper-left and Bob at the lower-right if:
- `Alice[0] <= Bob[0]` (Alice's x-coordinate ≤ Bob's x-coordinate)
- `Alice[1] >= Bob[1]` (Alice's y-coordinate ≥ Bob's y-coordinate)

### Fence Formation

Alice and Bob form a rectangular fence with:
- Upper-left corner: Alice's position
- Lower-right corner: Bob's position
- No other points can be inside or on the boundary

### Key Optimization: Sorting Strategy

The crucial insight is sorting points by:
1. **Primary**: x-coordinate (ascending)
2. **Secondary**: y-coordinate (descending)

This allows us to process points efficiently and use a sweeping technique with boundary updates.

## Solution Strategy

**Optimized Sweep with Boundary Tracking**

1. Sort points by x-coordinate (ascending), then y-coordinate (descending)
2. For each potential Alice position, maintain valid x and y ranges for Bob
3. Update boundaries dynamically as we find valid Bob positions
4. Use the sorted order to eliminate redundant checks

### Boundary Management

```
For Alice at position i, track valid Bob ranges:
- xRange: (Alice[x], infinity) initially
- yRange: (-infinity, Alice[y]) initially

When Bob is found at valid position:
- Update xRange[0] = Bob[x] (tighten left boundary)
- Update yRange[0] = Bob[y] (tighten bottom boundary)
```

## Algorithm Steps

1. Sort points: primary by x-coordinate ascending, secondary by y-coordinate descending
2. For each point i as potential Alice position:
   - Initialize valid x-range: (Alice[x] - 1, ∞)
   - Initialize valid y-range: (-∞, Alice[y] + 1)
3. For each subsequent point j as potential Bob position:
   - Check if Bob is within current valid ranges
   - If valid, increment count and update boundaries to prevent overlapping rectangles
4. Return total count

## Complexity Analysis

- **Time**: O(n²) - nested loops with sorting optimization
- **Space**: O(1) - only using constant extra space for boundary tracking
- **Improvement over naive**: Sorting eliminates need for explicit rectangle validation

## Implementation

### JavaScript Solution
```javascript
var numberOfPairs = function (points) {
    let ans = 0;

    // Sort by x-coordinate ascending, then y-coordinate descending
    points.sort((a, b) => a[0] - b[0] || b[1] - a[1]);

    for (let i = 0; i < points.length - 1; i++) {
        const pointA = points[i]; // Alice's position
        
        // Initialize valid ranges for Bob
        const xRange = [pointA[0] - 1, Infinity];
        const yRange = [-Infinity, pointA[1] + 1];

        for (let j = i + 1; j < points.length; j++) {
            const pointB = points[j]; // Bob's position

            // Check if Bob is within valid ranges
            if (
                pointB[0] > xRange[0] &&
                pointB[0] < xRange[1] &&
                pointB[1] > yRange[0] &&
                pointB[1] < yRange[1]
            ) {
                ans++;
                // Tighten boundaries to prevent overlapping rectangles
                xRange[0] = pointB[0];
                yRange[0] = pointB[1];
            }
        }
    }

    return ans;
};
```

### Python Solution
```python
def numberOfPairs(points):
    ans = 0
    
    # Sort by x-coordinate ascending, then y-coordinate descending
    points.sort(key=lambda p: (p[0], -p[1]))
    
    for i in range(len(points) - 1):
        point_a = points[i]  # Alice's position
        
        # Initialize valid ranges for Bob
        x_range = [point_a[0] - 1, float('inf')]
        y_range = [float('-inf'), point_a[1] + 1]
        
        for j in range(i + 1, len(points)):
            point_b = points[j]  # Bob's position
            
            # Check if Bob is within valid ranges
            if (point_b[0] > x_range[0] and point_b[0] < x_range[1] and
                point_b[1] > y_range[0] and point_b[1] < y_range[1]):
                ans += 1
                # Tighten boundaries to prevent overlapping rectangles
                x_range[0] = point_b[0]
                y_range[0] = point_b[1]
    
    return ans
```

### Java Solution
```java
public int numberOfPairs(int[][] points) {
    int ans = 0;
    
    // Sort by x-coordinate ascending, then y-coordinate descending
    Arrays.sort(points, (a, b) -> a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]);
    
    for (int i = 0; i < points.length - 1; i++) {
        int[] pointA = points[i]; // Alice's position
        
        // Initialize valid ranges for Bob
        int[] xRange = {pointA[0] - 1, Integer.MAX_VALUE};
        int[] yRange = {Integer.MIN_VALUE, pointA[1] + 1};
        
        for (int j = i + 1; j < points.length; j++) {
            int[] pointB = points[j]; // Bob's position
            
            // Check if Bob is within valid ranges
            if (pointB[0] > xRange[0] && pointB[0] < xRange[1] &&
                pointB[1] > yRange[0] && pointB[1] < yRange[1]) {
                ans++;
                // Tighten boundaries to prevent overlapping rectangles
                xRange[0] = pointB[0];
                yRange[0] = pointB[1];
            }
        }
    }
    
    return ans;
}
```

## Learning Takeaways

- **Time taken**: Quick solve (building on previous problem)
- **Hints needed**: 0 (applied sorting optimization from similar problems)
- **Key insight**: Sorting transforms O(n³) brute force into O(n²) sweep algorithm
- **Connection**: This problem demonstrates how sorting can dramatically improve geometric algorithms

## Key Differences from Problem I

- **Sorting optimization**: Eliminates need for explicit rectangle validation
- **Boundary tracking**: Dynamic range updates prevent overlapping rectangles
- **Sweep technique**: Process points in optimal order for efficiency

## Similar Problems

This problem teaches important concepts about:
- **Coordinate geometry with sorting**
- **Sweep line algorithms**
- **Boundary optimization techniques**
- **Transform brute force into efficient solutions**

These skills are essential for advanced geometric algorithm problems and competitive programming.