# Find the Number of Ways to Place People I

**LeetCode Problem**: [Find the Number of Ways to Place People I](https://leetcode.com/problems/find-the-number-of-ways-to-place-people-i/)

## Problem Overview

Given a 2D array of integer coordinates, count the number of pairs of points (A, B) where A is on the upper-left side of B, and there are no other points in the rectangle (or line) they form (including the border).

## Key Insights

### Understanding "Upper-Left"

A point A is upper-left of point B if:
- `A[0] <= B[0]` (A's x-coordinate is less than or equal to B's)
- `A[1] >= B[1]` (A's y-coordinate is greater than or equal to B's)

### Rectangle Formation

Two points A and B form a rectangle (or line if they share coordinates) with:
- Top-left corner: `(min(A[0], B[0]), max(A[1], B[1]))`
- Bottom-right corner: `(max(A[0], B[0]), min(A[1], B[1]))`

### Validation Check

For each potential pair (A, B), we must verify that no other point lies within the rectangle they form, including on the border.

## Solution Strategy

**Brute Force with Rectangle Validation**

1. Check every pair of points (A, B)
2. Verify A is upper-left of B
3. Check if any other point lies within their rectangle
4. Count valid pairs

### Rectangle Containment Check

```
Point C is inside rectangle formed by A and B if:
minX <= C[0] <= maxX AND minY <= C[1] <= maxY
```

## Algorithm Steps

1. Iterate through all pairs of points (i, j) where i ≠ j
2. For each pair, check if point i is upper-left of point j
3. If yes, check if any other point k lies within the rectangle formed by i and j
4. If no other points are found, increment the valid pair count
5. Return the total count

## Complexity Analysis

- **Time**: O(n³) - nested loops for pairs and validation
- **Space**: O(1) - only using constant extra space

## Implementation

### JavaScript Solution
```javascript
var numberOfPairs = function(points) {
    let validPairs = 0; 
    
    for (let i = 0; i < points.length; i++) {
        for (let j = 0; j < points.length; j++) {
            if (i === j) continue;
            
            let pairA = points[i];
            let pairB = points[j]; 
            
            // Check if A is upper-left of B
            if (pairA[0] <= pairB[0] && pairA[1] >= pairB[1]) {
                let valid = true;
                for (let k = 0; k < points.length; k++) {
                    if (k === i || k === j) continue;
                    let pairC = points[k]; 
                    if (isInsideRectangle(pairA, pairB, pairC)) {
                        valid = false;
                        break;
                    }
                }
                if (valid) validPairs++;
            }   
        }
    }
    return validPairs; 
};

function isInsideRectangle(pairA, pairB, pairC) {
    const minX = Math.min(pairA[0], pairB[0]);
    const maxX = Math.max(pairA[0], pairB[0]);
    const minY = Math.min(pairA[1], pairB[1]);
    const maxY = Math.max(pairA[1], pairB[1]);

    return (pairC[0] >= minX && pairC[0] <= maxX &&
            pairC[1] >= minY && pairC[1] <= maxY);
}
```

### Python Solution
```python
def numberOfPairs(points):
    valid_pairs = 0
    
    for i in range(len(points)):
        for j in range(len(points)):
            if i == j:
                continue
                
            pair_a = points[i]
            pair_b = points[j]
            
            # Check if A is upper-left of B
            if pair_a[0] <= pair_b[0] and pair_a[1] >= pair_b[1]:
                valid = True
                for k in range(len(points)):
                    if k == i or k == j:
                        continue
                    pair_c = points[k]
                    if is_inside_rectangle(pair_a, pair_b, pair_c):
                        valid = False
                        break
                if valid:
                    valid_pairs += 1
                    
    return valid_pairs

def is_inside_rectangle(pair_a, pair_b, pair_c):
    min_x = min(pair_a[0], pair_b[0])
    max_x = max(pair_a[0], pair_b[0])
    min_y = min(pair_a[1], pair_b[1])
    max_y = max(pair_a[1], pair_b[1])
    
    return (pair_c[0] >= min_x and pair_c[0] <= max_x and
            pair_c[1] >= min_y and pair_c[1] <= max_y)
```

### Java Solution
```java
public int numberOfPairs(int[][] points) {
    int validPairs = 0;
    
    for (int i = 0; i < points.length; i++) {
        for (int j = 0; j < points.length; j++) {
            if (i == j) continue;
            
            int[] pairA = points[i];
            int[] pairB = points[j];
            
            // Check if A is upper-left of B
            if (pairA[0] <= pairB[0] && pairA[1] >= pairB[1]) {
                boolean valid = true;
                for (int k = 0; k < points.length; k++) {
                    if (k == i || k == j) continue;
                    int[] pairC = points[k];
                    if (isInsideRectangle(pairA, pairB, pairC)) {
                        valid = false;
                        break;
                    }
                }
                if (valid) validPairs++;
            }
        }
    }
    return validPairs;
}

private boolean isInsideRectangle(int[] pairA, int[] pairB, int[] pairC) {
    int minX = Math.min(pairA[0], pairB[0]);
    int maxX = Math.max(pairA[0], pairB[0]);
    int minY = Math.min(pairA[1], pairB[1]);
    int maxY = Math.max(pairA[1], pairB[1]);
    
    return (pairC[0] >= minX && pairC[0] <= maxX &&
            pairC[1] >= minY && pairC[1] <= maxY);
}
```

## Learning Takeaways

- **Time taken**: 30 minutes
- **Hints needed**: 1 (isInsideRectangleFunction)
- **Key lesson**: Geometric problems often require careful boundary checking and understanding of coordinate relationships

## Similar Problems

This problem teaches important concepts about:
- **2D coordinate geometry**
- **Rectangle intersection and containment**
- **Brute force validation with geometric constraints**

These skills are useful for other geometric algorithm problems involving point relationships and spatial queries.