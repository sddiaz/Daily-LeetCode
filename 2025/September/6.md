# Minimum Operations to Make Array Elements Zero

**LeetCode Problem**: [3495. Minimum Operations to Make Array Elements Zero](https://leetcode.com/problems/minimum-operations-to-make-array-elements-zero/)

---

## Problem Overview

You’re given `queries`, where each query is `[l, r]`.
For each query, construct an array with all integers in `[l, r]`.

In one operation:

* Pick two numbers `a` and `b`
* Replace them with `⌊a/4⌋` and `⌊b/4⌋`

The task: Find the **minimum number of operations to reduce the whole array to zero** for each query, then return the sum across all queries.

---

## Key Insights

### 1. How many operations does a single number need?

* A number `x` requires **(number of times we divide by 4 until it reaches 0)**.
* That’s exactly `⌊log₄(x)⌋ + 1`.

Examples:

* `x = 1..3` → needs 1 op
* `x = 4..15` → needs 2 ops
* `x = 16..63` → needs 3 ops
* And so on.

---

### 2. Range-based grouping

Instead of iterating number by number, we:

* Partition `[l, r]` into ranges of the form `[4^k, 4^(k+1) - 1]`
* Each number in such a range requires exactly `k+1` operations

---

### 3. Pairing logic

Each operation reduces **two numbers** simultaneously.
So, for a query, if the total needed operations = `ops`,
then minimal operations = `ceil(ops / 2)`.

---

## Algorithm Steps

1. For each query `[l, r]`:

   * Initialize `totalOps = 0`
   * While `current ≤ r`:

     * Find largest `k` such that `4^k ≤ current`
     * Compute overlap of `[l, r]` with `[4^k, 4^(k+1)-1]`
     * Add `count * (k+1)` to `totalOps`
     * Move `current` past this range
   * Add `ceil(totalOps / 2)` to result
2. Return sum across all queries

---

## Complexity

* **Time**: O(Q · log r)
  Each query iterates through ranges of size powers of 4
* **Space**: O(1)

---

## Implementations

### Python

```python
import math

class Solution:
    def minOperations(self, queries: List[List[int]]) -> int:
        total_sum = 0

        for l, r in queries:
            total_ops = 0
            current = l

            while current <= r:
                k = 0
                while 4 ** (k + 1) <= current:
                    k += 1

                range_start = 4 ** k
                range_end = 4 ** (k + 1) - 1

                overlap_start = max(current, range_start)
                overlap_end = min(r, range_end)

                if overlap_start <= overlap_end:
                    count = overlap_end - overlap_start + 1
                    total_ops += count * (k + 1)

                current = overlap_end + 1

            total_sum += math.ceil(total_ops / 2)

        return total_sum
```

---

### JavaScript

```javascript
var minOperations = function(queries) {
    let sum = 0;

    for (let [l, r] of queries) {
        let totalOps = 0;
        let current = l;

        while (current <= r) {
            let k = 0;
            while (Math.pow(4, k + 1) <= current) {
                k++;
            }

            let rangeStart = Math.pow(4, k);
            let rangeEnd = Math.pow(4, k + 1) - 1;

            let overlapStart = Math.max(current, rangeStart);
            let overlapEnd = Math.min(r, rangeEnd);

            if (overlapStart <= overlapEnd) {
                let count = overlapEnd - overlapStart + 1;
                totalOps += count * (k + 1);
            }

            current = overlapEnd + 1;
        }

        sum += Math.ceil(totalOps / 2);
    }

    return sum;
};
```

---

### Java

```java
class Solution {
    public int minOperations(int[][] queries) {
        int sum = 0;

        for (int[] query : queries) {
            int l = query[0], r = query[1];
            int totalOps = 0;
            int current = l;

            while (current <= r) {
                int k = 0;
                while (Math.pow(4, k + 1) <= current) {
                    k++;
                }

                int rangeStart = (int)Math.pow(4, k);
                int rangeEnd = (int)Math.pow(4, k + 1) - 1;

                int overlapStart = Math.max(current, rangeStart);
                int overlapEnd = Math.min(r, rangeEnd);

                if (overlapStart <= overlapEnd) {
                    int count = overlapEnd - overlapStart + 1;
                    totalOps += count * (k + 1);
                }

                current = overlapEnd + 1;
            }

            sum += (totalOps + 1) / 2; // ceil division
        }

        return sum;
    }
}
```

---

## Learning Takeaways

* Break numbers into **power-of-4 ranges**
* Avoid brute force — use **math-based intervals**
* Greedy + grouping strategy simplifies a “hard”-tagged problem

---

Do you want me to also add **worked-out dry run examples** (step-by-step) for the Java/Python/JS code, like the one in your “Maximum Average Pass Ratio” template? That would make it *interview-ready*.
